# CardGame
Implementation of CardGame

This is a simple console application that simulates a deck of playing cards. The application uses enums, models, and utility classes to represent and manipulate the deck of cards.

# Application Structure
The application consists of the following files and folders:

* Program.cs: The main entry point of the application. It will create an instance of the Deck class, shuffle it, and deal the cards.
* Models: This folder contains all the model classes used in the application.
* Card.cs: A simple model class that represents a playing card with a Suit and a Rank.
* Deck.cs: The class that represents a deck of cards. It has a list of Card objects and methods to shuffle the deck and deal one card at a time.
* Enums: This folder contains the Suit and Rank enums used in the Card and Deck classes.
* Utils: This folder contains utility classes used in the application.
* Randomizer.cs: A simple class that encapsulates the logic for generating random numbers using the Random class.

# Randomization
The Randomizer class uses the Random class to generate random numbers. The minimum value of the random number generated by Random.Next() method is always 1, and the maximum value is the value of the argument passed to the method.

In the given code, the Shuffle() method uses Random.Next(n + 1) to generate a random number between 0 and n (inclusive), where n is the current number of cards in the deck. Therefore, the minimum value of the random number is 1, and the maximum value is 52 (which is the index of the last card in the deck since the deck has 52 cards in total).

# Deck and Card Classes
In this implementation, the Suit and Rank enums represent the different suits and ranks of the cards, respectively. The Card class has properties for the suit and rank of the card. The Deck class represents a deck of cards, and has a list of Card objects as a field.

The Deck constructor creates a standard deck of cards by iterating through each suit and rank and creating a new Card object for each combination. The Shuffle() method shuffles the cards by using the Fisher-Yates shuffle algorithm. The DealOneCard() method removes the first card from the deck and returns it. If there are no cards left in the deck, it returns null.

To use this implementation, you can create a new instance of the Deck class and call the Shuffle() method to shuffle the cards. You can then call the DealOneCard() method to deal one card at a time, until all the cards have been dealt.

# Logging
In .NET 6, the recommended approach for logging errors is to use the Microsoft.Extensions.Logging package.

To use it, you can follow these steps:

Add the Microsoft.Extensions.Logging NuGet package to your project.
Create an instance of the logger using the ILogger<T> interface, where T is the class or component where you want to log the errors.
Use the logging methods provided by the ILogger<T> interface to log the errors. Some common methods are LogDebug(), LogInformation(), LogWarning(), LogError(), and LogCritical().
You can also add additional information to the log messages using placeholders and arguments.
Using Logging in the Deck Class
In this implementation, we added a constructor that takes an instance of ILogger<Deck> as a parameter. This will allow

# How to Run
To run the application, open the project in Visual Studio 2022 and press the "Start" button. Alternatively, you can compile the project into an executable and run it from the command line or by double-clicking on the executable file.
